# Оптимизация хэш-таблиц при помощи SIMD инструкций и ассемблерного кода

## **Часть 1**

## Задача

- Написать хэш-таблицу для строк фиксированного размера и 6 заданных хэш-функций для неё и одну свою
- Преобразовать текст в набор слов без знаков пунктуации (кол-во слов не меньше 40 000)
- Поместить полученный набор слов в хэш-таблицу и построить диаграммы, отображающие длины цепочек в ячейках хэш-таблицы после вставки слов, для каждой хэш-функции
- выяснить, для какой хэш-функции количество коллизий наименьшее
- посмотреть, как транслируется код пятой и шестой хэш-функций

## Ход работы

Реализована хеш-таблица на двусвязном списке с использованием трех массивах, общих для всех списков. Размер таблицы - 2003
### Функции хэш-таблицы:
- вставка (если элемент уже есть есть в хэш-таблицы, повторная вставка не производится)

## Полученные результаты

<figure>
<img src="Images/charts/merged_3:3.png">
</figure>

### Исходники графиков
- [return 0](Images/charts/hash_func_1.png)
- [return int(word[0])](Images/charts/hash_func_2.png)
- [return  len(word)](Images/charts/hash_func_3.png)
- [return sum_ASCII(word) size=101](Images/charts/hash_func_4_101.png)
- [return sum_ASCII(word)](Images/charts/hash_func_4.png)
- [return ror(hash(n - 1)) * int(word[n])](Images/charts/hash_func_5.png)
- [return rol(hash(n - 1)) * int(word[n])](Images/charts/hash_func_6.png)
- [return djb2(word)](Images/charts/hash_func_7.png)
- [return crc32(word)](Images/charts/hash_func_8.png)

### Равномерность распределения

| Хэш-функция | Алгоритм | Дисперсия * 10<sup>2</sup>|
|:-----------:|:--------:|:---------:|
|   1   | return 0| 291.988|
|   2   | return int(word[0])  |7.228|
|   3   | return  len(word) |15.902|
|   4   | return sum_ASCII(word) | 0.207 |
|   5   | return ror(hash(n - 1)) * int(word[n])  | 0.034|
|   6   | return rol(hash(n - 1)) * int(word[n]) | 0.078|
|   7   | return djb2(word)  | 0.026 |
|   8   | return crc32(word) | 0.025 |

### Вывод

Лучшее распределение оказалось у хэш-функции CRC32. В дальнейшем будем использовать ее. К тому же мы сможем оптимизировать её вычисление при помощи SIMD
инструкции.


### Трансляция пятой и шестой хэш-функций

Компилятор `x86-64 gcc 13.2` на сайте https://godbolt.org/ транслирует код следующим образом

1)  **Используется sizeof(size_t)**

    *Исходный код:*
    ```C
        return (num >> sizeof(size_t) - 1) | (num << 1)
    ```

    **Оптимизация:** -O0

    *Полученный код:*

    ```assembly
        mov     rax, QWORD PTR [rbp-8]
        shr     rax, 7
        mov     rdx, rax
        mov     rax, QWORD PTR [rbp-8]
        add     rax, rax
        or      rax, rdx
    ```

    **Оптимизация:** -O1

    *Полученный код:*

    ```assembly
        mov     rdx, rax
        shr     rdx, 7
        add     rax, rax
        or      rdx, rax
    ```

    При оптимизации -O0 компилятор пересылает числа из памяти, что замедляет программу, а при оптимизации -O1 и выше используются только регистры

2)  **Используется прямая подстановка числа**

    *Исходный код:*
    ```C
        return (num >> 63) | (num << 1)
    ```

    **Оптимизация:** -O0

    *Полученный код:*

    ```assembly
        mov     rax, QWORD PTR [rbp-8]
        rol     rax
    ```
    **Оптимизация:** -O1

    *Полученный код:*

    ```assembly
    rol     rax
    ```
    При оптимизации -O0 компилятор пересылает число из памяти, а при оптимизации -O1 и выше используются только регистр, что ускоряет программу

**При использовании `sizeof(size_t)` компилятор использовал битовые сдвиги, а при прямой подстановке числа заменил мою функцию на ассемблерный циклический сдвиг, поэтому второй вариант оптимальнее. С пятой хэш-функцией ситуация аналогична.**

## **Часть 2**

## Задача

- при помощи профилирования определить время работы функций
- использую полученные данные найти два типа времени
    - работа функции с учетом времени работы вызываемых внутри функций
    - работа фукции без учета вызываемых  внутри функций
- использовать три вида оптимизации хэш-таблицы
    - SIMD инструкции
    - ассемблерные вставки
    - функции, целиком написанные на ассемблере
- оценить результаты оптимизации

##
